# ThreatAssessment

Threat Assessment (Web App Vulnerabilities)

In this lab I'll examine some web application vulnerabilities like poor authentication, SQL Injections, and Cross Site Scripting.

Starting WebGoat
The web server was already pre-installed and all I needed to do is run the program. From the menu bar on the top of the VM, I selected Applications > Accessories > Terminal. This opened up a Linux shell command terminal. Ran the following commands to start the web server. cd ~/tools/tomcat/bin & then sh startup.sh

 ![Image](https://github.com/user-attachments/assets/187cfade-068c-4359-8e33-f97e87dcdaea)

I used Firefox browser to connect to the Apache Tomcat server which hosts WebGoat. Before connecting, I made sure the browser is using the system proxy settings by opening the menu bar of the browser. Select Edit > Preferences > Advanced > Network Tab > Settings. Made sure the Use system proxy settings radio button was selected. Click OK and Close.

![Image](https://github.com/user-attachments/assets/92943d1d-ad5c-4174-b4d5-d728ad88b6e3)

I went to the Apache server homepage on my VM by entering http://localhost:8080/ into the Firefox address bar showing the Tomcat welcome page. 

![Image](https://github.com/user-attachments/assets/40572766-8c57-4d61-b889-5d7423599ae0)

Note: When running a program on port 80, I do not have to specify the port number as it is the default HTTP port used by most web applications and servers.

Setting up the Proxy Server
I will investigate the web traffic between my browser and the Web server using a web proxy called Paros. All web communication between the browser and web server will be sent to Paros (proxy server) before it reaches the appropriate destination.
I started Paros by first needing another Linux terminal window. Then ran these commands in the terminal window: cd ~/tools/paros & sh startserver.sh. The Java-based Paros will execute and I was greeted with its interface.

![Image](https://github.com/user-attachments/assets/acecb68d-d51b-4acb-8677-af58d9a1e4e5)

Then I needed to change the proxy server settings in Firefox to redirect the web traffic to the proxy server. The proxy server is ran under 127.0.0.1 and port 8080. On Paros menu under Tools > Options > Local Proxy, I did the following settings.
Address 127.0.0.1 
Port: 8008 (I changed it from 8080 to 8088) 

![Image](https://github.com/user-attachments/assets/e030615c-4151-42e7-9896-e1898654f3fd)

After I went back to my browser. Selected Edit > Preferences > Advanced > Network Tab > Settings. Then selected Manual Proxy Configuration radio button. Entered these values into the fields: HTTP: 127.0.0.1 Port: 8088 (the proxy settings need to match the setting on Paros)

![Image](https://github.com/user-attachments/assets/06acfb8c-42d7-4fb4-8f95-b0ecd9063869)

I just enabled all HTTP traffic generated by Firefox to be sent to the running Paros proxy server which can analyze HTTP traffic before it is sent off to its final destination. I reloaded http://localhost:8080/ on the browser, and saw Paros capture the web content sent between the server and the browser. 

 ![Image](https://github.com/user-attachments/assets/351121f5-0843-4eb9-ae40-d41f105eb339)

WebGoat Login
I went back to the browser in Ubuntu. Browse to http://localhost:8080/WebGoat/attack. When prompted for login information, the username is guest and the password is guest. On the WebGoat home page, clicked Start WebGoat.

 ![Image](https://github.com/user-attachments/assets/1383ed33-ee55-4a98-8b51-b95d32f3851e)

Went back to Paros. I saw Paros logs of the connection between the browser and WebGoat. 

 ![Image](https://github.com/user-attachments/assets/7fc34ca4-f410-4ff7-9b37-15d918224aa7)

On the left side of the screen is a list of WebGoat exercises I can try. I tried the first lesson, by clicking on “General” and underneath it chooses “HTTP Basics”. This WebGoat exercise will accept a value in the text box that I enter and reverse it. In the “Enter your name” textbox, I typed my name and clicked Go. 

 ![Image](https://github.com/user-attachments/assets/cb76a225-48eb-4c0b-8024-c8920213fc2f)

I could see the parameters sent between my browser and WebGoat with Paros. In Paros, looked under Sites > http://localhost:8080 > WebGoat > POST:Attack(Screen,menu). Changed the view from Raw View to Tabular View. I can see the session ID by looking under the Request tab in Paros next to the Cookie: reference.

 ![Image](https://github.com/user-attachments/assets/25e3ee58-6d32-4e41-80b6-53f92c796293)

The 2 parameters in the transactions using POST were for the person is joseph Okafor and the submit is Go!
Note: I can also see the solution for the exercise by clicking on Show Solution in WebGoat. For all the exercises below, I can either read instructions from this manual or read the instructions from Show Solution (I use Paros instead of WebScarab in my lab).

Authentication Flaws in Login
I’m going to exploit a common weakness in password retrieval systems in this section. Web applications such as Web e-mail and Web forums provide their users the ability to retrieve a forgotten password with security questions. The problem is that there is no criterion to the strength of the security answers and some questions are overly easy to guess.

I clicked on Authentication Flaws and underneath select Forgot Password in the left pane of WebGoat. This exercise will show how vulnerable a bad authentication scheme is. I’m going to retrieve the password of another user. I’m going to retrieve a password from a regular user with the username „webgoat‟. Typed in the username into the *User Name textbox and hit Submit. I was presented with an over simplistic security question of “What is your favorite color?” Tried different colors and saw what happens when you enter a wrong color as the security answer. Entered “red” and was able to retrieve the password for the „webgoat‟ user. Then I will try to retrieve the password for the WebGoat administrator account.

I wanted to retrieve the password of another user. I’m going to retrieve a password from a regular user with the username ‘webgoat’. typed in the user name into the User Name textbox and hit Submit. Was presented with an over simplistic security question of “What is your favorite color?”. Tried different colors and saw what happens when you enter a wrong color as the security answer. Entered “red” and I was able to retrieve the password for the „webgoat‟ user.
 
![Image](https://github.com/user-attachments/assets/8bbadbb8-72bb-4e70-b028-01e027c63906)

The administrator’s username and password were Webgoat for both username and password. A way to improve login security is increasing the password length and complexity

Injection Flaws – String SQL Injection 
SQL injection is used to gain access, extract data or compromise secured databases. The methods behind an attack are simple and the damage dealt can range from inconvenience to system compromise. First, I clicked on Injection Flaws and underneath selected String SQL Injection in the left pane in WebGoat. the exercise first prompts me to enter the last name Smith (SQL is case sensitive). A simple SQL query to a database would looks like SELECT * FROM user_data WHERE last_name = „Smith‟. Smith is the value I enter in the “Enter your name” textbox. The SQL will select all information about the user „Smith‟ from the database. There are 2 entries that have been obtained which are information about smith

 ![Image](https://github.com/user-attachments/assets/b74fb43b-506f-4faa-bdb5-e1bd3c2d8d5b)

I tried some SQL command like SELECT * FROM user_data WHERE name = „Smith’ OR ‘1’=’1‟. This SQL command will ask the database to show all user information since „1‟=‟1‟ is always true. String SQL injection exploits the vulnerability that a database that does not conduct checks on constraints so that attackers can inject SQL commands through the regular user interface. Then entered Smith’ OR ‘1’=’1 in the “Enter your last name” textbox. These commands brought up information of other users and their cc number.
 
![Image](https://github.com/user-attachments/assets/bd64fa3b-7f27-430a-aa1c-af084734af61)

Note: I could edit the website to not be able to just put in random strings and implement better validation coding.

Cross Site Scripting (XSS) – Stored XSS attack
Stored XSS attacks allow users to create message content that could cause another user to load an undesirable page or undesirable content when the message is viewed or accessed. In this exercise I created such a message.
 
On Cross-Site Scripting (XSS) and underneath select Stored XSS Attacks in the left pane in WebGoat. Then in the title text box, typed “XSS example”. In the message text box, copied and pasted the following HTML content. <script language="javascript" type="text/javascript">alert("Ha! Ha! You are hacked! ");</script>. Clicked on Submit. Which showed a popup message. 

 ![Image](https://github.com/user-attachments/assets/811653f6-1b91-4fec-9bfc-cd5c6e4d24d2)

Note: The implications of my results are that you could easily write script into a website that would affect the user on the other side of the webserver trying to access it.

Authentication Flaws in Session Management
I will illustrate the vulnerability of session management using Cookies. Using a proxy server, the attacker will be able to trap important information regarding transaction authorization information, such as authorization header and cookies. By manipulating this login information, the attacker can re-login as a different user.

I need to observe what HTTP requests are sent between the browser and the server. I can trap the web requests at the proxy server. To do this, on Paros, click on the Trap tab, check Trap request. This will trap the HTTP request at the proxy server, while the server waits for the HTTP request to arrive, letting the proxy server be the “man-in-the-middle” and giving the proxy server the ability to manipulate the HTTP request before letting the request continue to its destination. I clicked on Authentication Flaws and underneath select Basic Authentication on the left pane in WebGoat. I read the WebGoat description of the exercise and clicked on Submit. I needed to setup Paros before clicking Submit to trap the request as mentioned previously in order to continue.

Went to Paros and look under Sites > http://localhost:8080 > WebGoat > POST:Attack(Screen,menu)(SUBMIT,person). I saw my HTTP request intercepted at the proxy server and can see the HTTP command I have just submitted. The HTTP header contains a basic authentication header called “Authorization” within the HTTP request. I was able to see its value on the HTTP header window in Paros. The value should be some code following “Authorization: Basic” in the HTTP header request. the code after authorization: Basic is z3vlc3q6z3vlc3q=

 ![Image](https://github.com/user-attachments/assets/35bf06a5-36f6-433a-b620-3e38f0b57486)

The code is encoded in BASE64 and I need to decode it to see the ASCII value. Used the decoder under Tools, Encoder/Hash. Decoded it using BASE64 decode. The plain text value of the authentication header that I just decoded shows guest.
 
![Image](https://github.com/user-attachments/assets/939dd47a-14cd-48a1-9a81-d7617da4b489)

Now, unchecked “Trap request” and clicked Continue to let the HTTP request go through. Went back to WebGoat. Entered the name of the authentication header (Authorization) and the value of it (the code I have just decoded above) into the appropriate fields. then Submit.
 
![Image](https://github.com/user-attachments/assets/d2c6b871-289d-4135-a3c6-5689e0c03f60)

We can use Paros to alter the HTTP request and corrupt the authentication header and JSESSIONID. Go to Paros, check “Trap request” to intercept the HTTP command. 13 

WebGoat will ask me to further investigate authentication by logging in again using the username basic with password basic. Authentication header and Cookie (JSESSIONID) are the information that HTTP uses to manage a session. I’m currently logging in as guest. The server can recognize me since the browser sends the server the same authentication header and JSESSIONID every time. If I want the server to ask me for a re-login, I need to corrupt my authentication header and JSESSIONID. Went back to WebGoat, clicked on Basic authentication. then back to Paros. I can see the intercepted HTTP command under the Trap tab. I can then delete the value after Authorization and Cookie. Clicked Continue to send the HTTP command to the server. I will be prompted for re-login. I can now re-login as user basic using password basic. Back to Paros. I will see the new authorization code for the user but the cookie (JSESSIONID) is the same because the browser sent the value that was cached. So, corrupt the Cookie by changing the JSESSIONID value to =novalidsession, unchecked Trap request and click Continue. WebGoat losses all the information about the user “guest” and regards me as a new user “basic”. Now logged in as the user “basic” using the password “basic” and clicked on Start WebGoat to restart the exercise. Clicked on Basic Authentication to complete this exercise. 

Note: Changed setting in Paros back to port 8080 such as tools->options->Local Proxy->Address 127.0.0.1 port: 8008

Turning off virtual machine

Changed the settings in Paros back to port 8080 such as tools->options->Local proxy->Address 127.0.0.1 port: 8080. Clicked on File| Exit to close Paros.

 ![Image](https://github.com/user-attachments/assets/e64533c7-2242-485c-8121-e78a617becb9)

After finishing this exercise, I should reset Firefox proxy setting so it stops using the proxy server. Otherwise, I would not be able to visit web sites without running the proxy server. To do so, Launched my Firefox web browser, and follow its menu item path “Edit|Preferences|Advanced|network Tab|Settings button” to reach the “Connection Settings” window. Checked the “Use System Proxy Settings” checkbox. 
 
![Image](https://github.com/user-attachments/assets/664899a1-e223-476d-ba64-da420b5b62ae)

Ran the following commands to stop the web server. cd ~/tools/tomcat/bin & sh shutdown.sh 

 ![Image](https://github.com/user-attachments/assets/6d195ea4-7082-4363-992e-83528e43bd91)


